<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>Lab 4</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" media="screen" href="extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="extensions/scale/deck.scale.css">

  <link rel="stylesheet" media="screen" href="extensions/toc/deck.toc.css">
  <link rel="stylesheet" media="screen" href="extensions/notes/deck.notes.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/style/neon.css">

  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/transition/fade.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="core/print.css">

  <!-- Required Modernizr file -->
  <script src="modernizr.custom.js"></script>
</head>

<body>
  <div class="deck-container">

    <!-- Begin slides. Just make elements with a class of slide. -->

    <section class="slide">

      <h2>Lab 4: Inheritance & Polymorphism</h2>

      <img src="https://external-preview.redd.it/1XuftAfkSNyK2nypxkAZRyR0H2aHnUyBIxFVZ59pj08.png?auto=webp&s=b06753c948d6c0c0513798fe986a6132d94e5172">
      
      <!-- 
        You're gonna experience this during your project. 
        
        Some tips:
            - plan before you code -> draw out the class diagrams first (maybe sequence diagrams too, up to you)
              - please make sure when y'all meet, at least 1 person knows what class diagrams and sequence diagrams are
              - really ensure that this happens: the person can explain to the group such that everyone have a basic understanding + are able to participate in the planning process
              - yes it's hard to understand everything and implement them immediately especially with all the other mods and commitments you have
                - that's why it's a group assignment: work as a group and break down big tasks into small parts
                - each pair studies a small part (e.g. a pair masters class diagram, another pair sequence diagram)
                - the pair helps each other to understand + explain to the other pair what you've learnt
              - also, have a realistic sense of everyone's coding experience and understanding of the course so far 
                -> you'll then know how much effort you're gonna have to put to patch up each other's weaknesse
                -> or you can allocate the work according to your strengths / preference (e.g. coding more or do docu more)
                -> but please do help your teammates if they're struggling - it's good for the team and good for you (teaching helps to improve your understanding)
            - but **don't do overly detailed planning without coding** (i.e. don't use a waterfall style of project management 
              - adopt agile principles: simple draft plan -> code it out -> repeat and iterate quickly (update plan when you realize you missed something out while you code)
            - rather, after reading the requirements (and discussing as a group, which will help to ensure you don't miss key points), 
              do a **quick** first draft of class diagrams
              (i.e. determine the objects needed, what mutable states it should hold (attributes), what it can do (methods))
              and a **quick** + brief sketch of the sequence diagrams
              (i.e. determine the flow of the program - which methods are called, which methods come after)
            - again, DO NOT be a perfectionist here - humans are very poor at such long-term logical planning 
              (no one can plan a non-trivial program with perfect foresight + IRL, requirements change and screw up your plan)
              (plans are nice to look at + give you a false sense of belief that everything is fine, but the deal is to deliver a working product with actual code)
              (but it is still important to plan and importantly, think about how OO principles can be adopted in your program
              - else you'll end up smoking stuff up when you try to justify the use of OO design principles
            - with the brief plans drafted, get started on coding -> revise your plans (prolly once in the middle, one more near/at the end)
      -->
      
    </section>

    <section class="slide">

      <h2>Quick Recap from Lab 3</h2>

      <h3>Understanding OOP by comparing it with other programming paradigms</h3>

      <ul>
        <li>
          OOP is done at a <strong>higher</strong> level of abstraction (objects)
          <ul>
            <li>Objects communicate with each other using messages sent via methods (≈ verbs)</li>
            <li>Methods usually modify attributes (≈ nouns)</li>
            <li>Thus, it's great for situations that require mutable states (i.e. attributes)</li>
          </ul>
        </li>

        <li>Attributes and Methods are <strong>more closely knitted</strong> vs procedural programming</li>
        <!-- You can do the same thing in procedural programming:
              e.g. You can implement Lab 3 in Python and create a dictionary called 
                   'Plane' with keys = seat_id, value = customer_id (each key-value pair is a plane seat)
                   and then separately write functions to manipulate the dictionary -->
        
        <!-- Also, methods aren't like functions in functional programming. 
        Key ideas in FP: no side effect, recursion replace loops, 
        recall how functions are like in Math (map input to an output + can be nested) -->
         <ul>
          <li>Could have implemented Lab 3 tasks via procedural programming too</li>
          <li>However, it becomes messy and unmaintainable for large scale programs
            <!-- - OOP comes to the rescue! -->
          </li>
        </ul> 

        <li>Still based on imperative programming 
            (you tell it <strong>how</strong> to do what you want to do)
        </li>

      </ul>

    </section>

    <section class="slide">

      <h2>OOP Principles</h2>

      <ul>
        <li>
          <h3><strong>A</strong>bstraction</h3>
        </li>
          <ul>
            <li>Essential characteristics of object that distinguish it from others</li>
            <!-- Abstract away the details -->
          </ul>
        <li>
          <h3><strong>P</strong>olymorphism</h3>
        </li>
          <ul>
            <li>Same message sent to the object, but each can do different stuff</li>
          </ul>
        <li>
          <h3><strong>I</strong>nheritance</h3>
        </li>
          <ul>
            <li>Child learns from parent (class), but child can do their own things too</li>
          </ul>
        <li>
          <h3><strong>E</strong>ncapsulation</h3>
        </li>
          <ul>
            <li>Hiding impementation and protecting data: like how a capsule protects what's inside</li>
          </ul>
        <!--So if you find it difficult to remember, it might help to have a pie :) -->
        <!-- Check out the Notes that are available in NTULearn (course notes for 2nd half) 
              Specifically, the OODP-OOP-tkl.pdf file is a very digestable summary. -->
      </ul>

    </section>

    <!-- <section class="slides">
      <h2>Abstraction</h2>
    </section>

    <section class="slides">
      <h2>Polymorphism</h2>
    </section>

    <section class="slides">
      <h2>Inheritance</h2>
    </section>

    <section class="slides">
      <h2>Encapsulation</h2>
    </section> -->

    <section class="slide">
      
      <h2>OOP Principles in other paradigms</h2>

      <h3>The 4 OOP principles aren't unique to OOP</h3>

      <ul>
        <li>Abstraction and Encapsulation can be done without objects</li>
        <li>Inheritance can be simulated in Functional Programming via closures</li>
        <li>Functions can be overloaded to achieve polymorphism</li>
      </ul>
      
    </section>

    <section class="slide">
      
      <h2>OOP Principles in other paradigms</h2>

      <h3>The 4 OOP principles aren't unique to OOP</h3>

      <ul>
        <li>Abstraction and Encapsulation can be done without objects</li>
      </ul>

      <!-- 
      
      Abstraction and Encapsulation are actually quite interlinked (and confused with each other) 

      "Abstraction is the concept of describing something in simpler terms, i.e abstracting away the details, in order to focus on what is important 
      (This is also seen in abstract art, for example, where the artist focuses on the building blocks of images, such as colour or shapes). 
      The same idea translates to OOP by using an inheritance hierarchy, where more abstract concepts are at the top and more concrete ideas, 
      at the bottom, build upon their abstractions. At its most abstract level there is no implementation details at all"
      (https://stackoverflow.com/questions/8960918/encapsulation-vs-abstraction, 2nd answer)

      There are 2 interpretations of encapsulation (references provided in the last slide):
      1. The usual idea of information hiding, as mentioned in the previous slide.
      2. The extended idea of how attributes and methods are one single unit. ("encapsulate details into an object")
      
      tl;dr
      Abstraction is choosing what to show, Encapsulation is choosing what to hide.
      The confusion comes in when people include the implications of abstraction
      (if you show only the essentials, you're also hiding the things not shown)
      into the definition of abstraction (making it more generic) and say things like
      "encapsulation is a strategy used as part of abstraction".
      So by this definition, abstraction becomes a concept and encapsulation becomes the means of implementing it. 

      We need to determine the right level of abstraction in OOP because 
      e.g. in Java we want to define abstract classes, where we identify the characteristics (e.g. car has 4 wheels and an engine),
      define abstract methods and then leave the implementation to another class that inherits that abstract class. 
      A program that does abstraction at the right level will then achieve a suitable level of coupling (typically loose).

      "As an example, at the top might be an interface with a single method, 
      then the next level, provides several abstract classes, which may or may not fill in some of the details about the top level, 
      but branches by adding their own abstract methods, 
      then for each of these abstract classes are concrete classes providing implementations of all the remaining methods."

      (If you're a visual person, it'll help to visualise it like a tree: the tree trunk is like an interface, 
      branches like the various abstract classes, twigs are the subclasses and finally the leaves are the concrete classes.
      Ultimately leaves are the ones that produce food, like how the concrete class have the final implementation;
      but the scaffolds provided by the trunk is an essential structure that make things consistent
      (not many trees have shoots branching off along the entire length of the trunk - they are usually at one end of it)
      So when you're coding, it's like an upside-down tree. The next time you look at a tree, you can think about OOP ;) )

      As an aside: 
      CS is a relatively new field and the community hasn't reached a consensus on the precise definition of many terms.
      That might be the reason why some of you might struggle / find parts of it annoying - it's not always as determinstic and factual.
      For such matters, you'll need to learn how to deal with ambiguity, develop your understanding and argue your case when needed.
      But if you're sitting for an exam, you won't have the luxury of time to do that 
      - it'll then be better to adopt what you're taught, just for the purpose of the exam
      - but keep in mind what you've learnt and hold on to it, you might actually be right 
      - but if time proves you wrong and the evidence is overwhelming, be magnanimous about it and adopt the consensus

      -->

      <p>Abstraction is a very generic concept that is more than just the implementation you see in Java <br>

      (i.e. <a href="https://www.geeksforgeeks.org/abstraction-in-java-2/">interfaces and abstract classes</a> 
      is only one way to define the level of abstraction to work at)</p>

      <!-- <ul>
        <li>When you're designing APIs in any language, you often have to define the layer of abstraction users can interact with your program</li>
        <li>It's just the idea of working at different levels of complexity - in Java it's typically at a level of objects: nouns and verbs</li>
      </ul> -->
      
      <p>Encapsulation is actually pretty omnipresent:</p>
      <ul>
        <li>`#include &lt;stdio.h&gt;` in <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)#Examples">C</a>,
           <!-- https://stackoverflow.com/questions/52645937/is-encapsulation-possible-without-oop -->
           <!--See also https://en.wikipedia.org/wiki/Opaque_data_type  -->
          <a href="https://stackoverflow.com/questions/26216563/how-to-do-encapsulation-in-python">name mangling</a> in Python </li>
        <li>Whenever you interact with an API, many things (data and other functions) are hidden from view</li>
          <!-- https://www.insidetheiot.com/encapsulation-interfaces-apis/ -->
        <li>Java and C++ allows you to implement encapsulation more explicitly via access modifiers 
          <!-- (private, public) -->
        </li>
      </ul>

    </section>

    <section class="slide">
      
      <h2>OOP Principles in other paradigms</h2>

      <h3>The 4 OOP principles aren't unique to OOP</h3>

      <ul>
        <li>Inheritance can be simulated in Functional Programming via closures</li>
      </ul>

      <ol>
        <li>Refer to <a href="https://se-education.org/learningresources/contents/functionalProgramming/intro.html">this</a>
          for a good 3 minutes intro of functional programming, with code examples</li>
        <li>Then read <a href="https://stackoverflow.com/questions/36636/what-is-a-closure">this</a>
          to understand what a closure is.</li>
          <!-- See also https://en.wikipedia.org/wiki/Closure_(computer_programming) for an example in Python -->
          <!-- This actually made the most sense for me, likley for you too if you remember CZ1006 and CZ1007:
            "a closure is a stack-frame which is not deallocated when the function returns. 
            (as if a 'stack-frame' were malloc'ed instead of being on the stack!)" 
            From https://stackoverflow.com/questions/1083419/can-someone-define-what-a-closure-is-in-real-world-language -->
        <li>Finally, read <a href="https://stackoverflow.com/questions/28431201/python-equivalent-of-inheritance-with-closures">this</a>
          to see how closures are related to inheritance.</li>
      </ol>

      <p>
        Essentially, given a function A that returns function B, 
        <strong>closure</strong> refers to the local variables defined / used in function B that persists although we have already exited from function A.
      </p>

      <p>
        With closures, we can 'inherit' prior states / attributes and functions that have been defined and used in another function.
        <!-- (though not perfectly - not as powerful as the many things you can do with inheritance in Java, e.g. interface, abstract class) -->
      </p>
      
    </section>

    <section class="slide">
      
      <h2>OOP Principles in other paradigms</h2>

      <h3>The 4 OOP principles aren't unique to OOP</h3>

      <ul>
        <li>Functions can be overloaded to achieve polymorphism</li>
      </ul>

      <p>Polymorphism ≈ same message sent (e.g. move()), each do different stuff (e.g. fly, swim, walk) </p>
      
      <p>This is achieved in Java via <strong>method overriding</strong>: subclass redefines methods defined in superclass.<br>
        But it isn't the only way to do it.</p>
      <!-- https://stackoverflow.com/questions/12893907/are-polymorphism-overloading-and-overriding-similar-concepts/12894211 -->

      <p>In <a href="https://pythonspot.com/method-overloading/">method overloading</a> 
        (e.g Python), you can also create 1 function that will do different things.<br>
        By defining the method with default keyword arguments, you can call functions with varying number of arguments and do different things.
      </p>

      <!-- https://stackoverflow.com/questions/12893907/are-polymorphism-overloading-and-overriding-similar-concepts/12894211 -->


      <!-- In sum, "Encapsulation is pretty easy, polymorphism is doable - but inheritence is tricky"
           https://stackoverflow.com/questions/351733/how-would-one-write-object-oriented-code-in-c -->
      
    </section>

    <section class="slide">
      <h2>Value of OOP and when to use it</h2>
      <ul>
        <li>
          <h3>Strengths</h3>
          <p>If designed well, classes are easily reusable & extensible (very big if!) <br> 
            > faster and cheaper development ; innate modularity allows teamwork
          </p>
          <!-- (recall in Lab 2 when we wrote Java methods and I mentioned about how a huge task like coding a calculator can be broken down into smaller tasks) -->
        </li>
        <li>
          <h3>Weaknesses</h3>
          <p>Not very memory efficient, more lines of code, not easy to do well IRL <br>
            > poorly designed classes lead to spaghetti code</p>
        </li>
        <li>
          <h3>Use it when objects are the most natural representation</h3>
          <p>'OOP works just as well for representing abstract concepts, such as "UserAccount" or "PendingSale", 
            as for visible interface elements like "Window" and "Button"'</p>
          
        </li>
        <li>
          <h3>Hard to have complete foresight about how all the objects interact</h3>
          <!-- you'll experience this in the group assignment! -->
          <p>"A good programmer will use strategies from both paradigms together in the battle against complexity."</p>
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>Lab 4 Deliverables</h2>

      <h3>Submit 1 .zip file to NTULearn (under ‘Assignments’)</h3>

      <ul>
        <li>Your zip file should contain <strong>17 .java files</strong></li>
        <ul>
          <li>Numbers.java, Sorting.java, Strings.java, SalesPerson.java, WeeklySales.java</li>
          <li>Shape.java</li>
          <li>Shape2DApp.java, Circle.java, Triangle.java, Sqaure.java, Rectangle.java</li>
          <li>Shape3DApp.java, Sphere.java, Pyramid.java, Cuboid.java, Cone.java, Cylinder.java</li>
        </ul>
        <li>If you’re using Eclipse and your first line contains `package ...`, <strong>remove</strong> it before submitting</li>
        <li>No need to submit the .class file </li>
        <li>Follow the filename convention specified on NTULearn</li>
      </ul>
    </section>

    <section class="slide">
      
      <h2>References and Additional Readings</h2>

      <p>This slide deck was created using <a href="https://github.com/imakewebthings/deck.js/">deck.js</a> and exported via <a href="https://github.com/astefanutti/decktape">decktape</a>. <br>
        <!-- decktape --screenshots=true --screenshots-directory='./' deck ./deck.js-latest/boilerplate.html ./slides.pdf -->
        It's no longer maintained, but it's still usable and easy to pick up via <a href="http://imakewebthings.com/deck.js/introduction/">examples</a>. <br>
        (all you need is HTML - with CSS and JS, you can make even better slides - it supports <a href="https://github.com/tmbrggmn/deck.js-markdown">Markdown</a> too)

        <p>

        You'll see an example using <strong>reveal.js</strong> for Lab 5 :) 

      </p>

      <p>A large part of the Lab 3 and Lab 4 notes are built on top of issues mentioned 
        <a href="https://stackoverflow.blog/2020/09/02/if-everyone-hates-it-why-is-oop-still-so-widely-spread/">here</a>
         - it is worth a read.</p>

      <ul>
        <li><a href="https://www.reddit.com/r/ProgrammerHumor/comments/418x95/theory_vs_reality/">Slide 1 Image</a></li>
        <li>More discussions about 
          <a href="https://softwareengineering.stackexchange.com/questions/359042/can-a-class-achieve-abstraction-without-implementing-an-interface-or-extending-a">abstraction</a>

          
 
        </li>
        <li>Inheritance can lead to <a href="https://dzone.com/articles/is-inheritance-dead">exploding class hierarchy</a>
          → can be addressed by the <a href="https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm">decorator pattern</a>. <br>
          Do read up on design patterns - you'll cover it in CZ2006 and CZ3003 too.
        </li>
        <li><a href="https://www.johndcook.com/blog/2011/07/19/you-wanted-banana/">You wanted a banana but you got a gorilla holding the banana</a>
        <br>(having the right amount of encapsulation reduces this issue, but other paradigms are cleaner) </li>
      </ul>

    </section>

    <!-- End slides. -->

    <!-- Begin extension snippets. Add or remove as needed. -->

    <!-- deck.navigation snippet -->
    <div aria-role="navigation">
      <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
      <a href="#" class="deck-next-link" title="Next">&#8594;</a>
    </div>

    <!-- deck.status snippet -->
    <p class="deck-status" aria-role="status">
      <span class="deck-status-current"></span>
      /
      <span class="deck-status-total"></span>
    </p>

    <!-- deck.goto snippet -->
    <form action="." method="get" class="goto-form">
      <label for="goto-slide">Go to slide:</label>
      <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
      <datalist id="goto-datalist"></datalist>
      <input type="submit" value="Go">
    </form>

    <!-- End extension snippets. -->
  </div>

<!-- Required JS files. -->
<script src="jquery.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<script src="extensions/toc/deck.toc.js"></script>
<script src="extensions/notes/deck.notes.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
  $(function() {
    $.deck('.slide');
  });
</script>
</body>
</html>
